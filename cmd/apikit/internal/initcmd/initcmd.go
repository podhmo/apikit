package initcmd

import (
	"flag"
	"fmt"
	"io"
	"path/filepath"

	"github.com/podhmo/apikit/cmd/apikit/internal/clilib"
	"github.com/podhmo/apikit/code"
	"github.com/podhmo/apikit/pkg/emitgo"
)

func New() *clilib.Command {
	fs := flag.NewFlagSet("init", flag.ExitOnError)
	var options struct {
		Silent bool `json:"silent"`
	}
	fs.BoolVar(&options.Silent, "silent", false, "silent option")

	fs.Usage = func() {
		name := fs.Name()
		fmt.Fprintf(fs.Output(), "Usage of %s <rootpkg>:\n\n", name)
		fs.PrintDefaults()
		fmt.Fprintln(fs.Output(), "  rootpkg")
		fmt.Fprintln(fs.Output(), "\tthe package path of root package")
	}

	return &clilib.Command{
		FlagSet: fs,
		Options: &options,
		Do: func(path []*clilib.Command, args []string) (err error) {
			cmd := path[len(path)-1]
			if err := cmd.Parse(args); err != nil {
				return err
			}
			if cmd.NArg() < 1 {
				cmd.Usage()
				return fmt.Errorf("init <rootpkg>")
			}

			rootpkgPath := cmd.Args()[0]
			cfg := code.DefaultConfig()
			cfg.Verbose = !options.Silent
			cfg.Header = ""

			rootpkg := cfg.Resolver.NewPackage(rootpkgPath, "main")
			codepkg := rootpkg.Relative("design/code", "")
			actionpkg := rootpkg.Relative("action", "")

			ecfg := emitgo.NewConfig(filepath.Base(rootpkgPath), rootpkg)
			ecfg.Verbose = cfg.Verbose
			ecfg.DisableManagement = true

			emitter := ecfg.NewEmitter()
			defer emitter.EmitWith(&err)

			{
				here := codepkg
				c := cfg.NewCode(here, "code.go", func(w io.Writer, c *code.Code) error {
					c.Import(cfg.Resolver.NewPackage("github.com/morikuni/failure", ""))
					source := `
// error codes for your application.
const (
	NotFound        failure.StringCode = "NotFound"
	Unauthorized    failure.StringCode = "Unauthorized"
	Forbidden       failure.StringCode = "Forbidden"
	ValidationError failure.StringCode = "ValidationError"
)

func HTTPStatusOf(err error) int {
	if err == nil {
		return 200 // http.StatusOK
	}

	c, ok := failure.CodeOf(err)
	if !ok {
		return 500 // http.StatusInternalServerError
	}
	switch c {
	case Unauthorized:
		return 401 // http.StatusUuauthorized
	case Forbidden:
		return 403 // http.StatusForbidden
	case NotFound:
		return 404 // http.StatusNotFound
	case ValidationError:
		return 422 // http.StatusUnprocessableEntity // or http.StatusBadRequest?
	default:
		return 500 // http.StatusInternalServerError
	}
}`
					fmt.Fprintln(w, source)
					return nil
				})
				emitter.Register(here, c.Name, &code.CodeEmitter{Code: c})
			}
			{
				here := actionpkg
				c := cfg.NewCode(here, "Hello.go", func(w io.Writer, c *code.Code) error {
					c.Import(cfg.Resolver.NewPackage("context", ""))
					c.Import(cfg.Resolver.NewPackage("log", ""))
					c.Import(cfg.Resolver.NewPackage("os", ""))
					source := `
type HelloOutput struct {
	Message string` + "`json: \"message\"`" + `
}
func Hello(ctx context.Context, logger *log.Logger) (*HelloOutput, error) {
	logger.Printf("hello")
	return &HelloOutput{Message: "hello"}, nil
}

func NewLogger() (*log.Logger, error) {
	return log.New(os.Stderr, "app ", 0), nil
}
`
					fmt.Fprintln(w, source)
					return nil
				})
				emitter.Register(here, c.Name, &code.CodeEmitter{Code: c})
			}
			{
				here := rootpkg
				c := cfg.NewCode(here, "gen.go", func(w io.Writer, c *code.Code) error {
					c.Import(cfg.Resolver.NewPackage("log", ""))
					c.Import(cfg.Resolver.NewPackage("context", ""))

					c.Import(cfg.Resolver.NewPackage("github.com/podhmo/apikit/pkg/emitgo", ""))
					c.Import(cfg.Resolver.NewPackage("github.com/podhmo/apikit/web", ""))
					c.Import(cfg.Resolver.NewPackage("github.com/podhmo/apikit/web/webgen/gen-chi", "genchi"))

					// c.Import(cfg.Resolver.NewPackage("github.com/podhmo/apikit/plugins/scroll", ""))

					c.Import(codepkg)
					c.Import(actionpkg)
					source := `
// generate code: VERBOSE=1 go run gen.go

func main() {
	if err := run(); err != nil {
		log.Fatalf("!! %+v", err)
	}
}

func newRouter() *web.Router {
	r := web.NewRouter()
	r.Get("/hello", action.Hello)
	return r
}

func run() error {
	ctx := context.Background()
	return emitgo.NewConfigFromRelativePath(action.Hello, "..").EmitWith(func(emitter *emitgo.Emitter) error {
		emitter.FilenamePrefix = "gen_" // generated file name is "gen_<name>.go"


		c := genchi.DefaultConfig()
		// c.Override("logger", action.NewLogger) // register provider as func() (*log.Logger, error)
	
		g := c.New(emitter)
		r := newRouter()
		if err := g.Generate(ctx, r, code.HTTPStatusOf); err != nil {
			return err
		}
		
		// // use scroll plugin (string type version)
		// return g.ActivatePlugins(ctx, g.RuntimePkg,
		// 	scroll.Options{LatestIDTypeZeroValue: ""}, // latestId is string
		// )
		return nil
	})
}
`
					fmt.Fprintln(w, source)
					return nil
				})
				c.Header = `// +build apikit

// this code is generated by "apikit init"

`
				emitter.Register(here, c.Name, &code.CodeEmitter{Code: c})
			}
			return nil
		},
	}
}
