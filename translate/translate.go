package translate

import (
	"fmt"
	"io"
	"reflect"

	"github.com/podhmo/apikit/resolve"
	"github.com/podhmo/apikit/tinypkg"
)

type Translator struct {
	Tracker  *Tracker
	Resolver *resolve.Resolver
	EmitFunc EmitFunc

	providerVar *tinypkg.Var
}

func NewTranslator(resolver *resolve.Resolver, fns ...interface{}) *Translator {
	tracker := NewTracker()
	for _, fn := range fns {
		def := resolver.Def(fn)
		tracker.Track(def)
	}
	return &Translator{
		Tracker:  tracker,
		Resolver: resolver,
		EmitFunc: defaultEmitFunc,
	}
}

func (t *Translator) Override(name string, providerFunc interface{}) (prev *resolve.Def, err error) {
	rt := reflect.TypeOf(providerFunc)
	if rt.Kind() != reflect.Func {
		return nil, fmt.Errorf("unexpected providerFunc, only function %v", rt)
	}
	return t.Tracker.Override(rt.Out(0), name, t.Resolver.Def(providerFunc)), nil
}

type Emitter interface {
	Emit(w io.Writer, code *Code) error
}

type EmitFunc func(w io.Writer, code *Code) error

func (f EmitFunc) Emit(w io.Writer, code *Code) error {
	return f(w, code)
}

const Header = `// Code generated by "github.com/podhmo/apikit"; DO NOT EDIT.

`

func defaultEmitFunc(w io.Writer, code *Code) error {
	fmt.Fprintln(w, Header)
	fmt.Fprintf(w, "package %s\n\n", code.Here.Name)
	if err := code.EmitImports(w); err != nil {
		if err != ErrNoImports {
			return err
		}
	} else {
		io.WriteString(w, "\n")
	}
	return code.EmitCode(w)
}
